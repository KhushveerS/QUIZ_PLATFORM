// AI helpers for Gemini API integration
import { Question } from "@/components/Quiz/QuestionCard";

export interface GeminiConfig {
  apiKey: string;
  model?: string;
}

export interface QuizGenerationRequest {
  topic: string;
  difficulty: 'easy' | 'medium' | 'hard';
  questionCount: number;
  questionType?: 'multiple-choice' | 'true-false' | 'mixed';
}

export class GeminiAI {
  private apiKey: string;
  private model: string;
  private baseUrl: string = 'https://generativelanguage.googleapis.com/v1beta';

  constructor(config: GeminiConfig) {
    this.apiKey = config.apiKey;
    this.model = config.model || 'gemini-1.5-flash';
  }

  async generateQuiz(request: QuizGenerationRequest): Promise<Question[]> {
    const prompt = this.buildQuizPrompt(request);
    
    try {
      const response = await fetch(`${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No content generated by Gemini API');
      }

      return this.parseQuizResponse(generatedText);
    } catch (error) {
      console.error('Error generating quiz with Gemini:', error);
      // Return fallback questions if API fails
      return this.getFallbackQuestions(request);
    }
  }

  private buildQuizPrompt(request: QuizGenerationRequest): string {
    return `
Generate ${request.questionCount} ${request.difficulty} difficulty multiple-choice questions about ${request.topic}.

Format your response as a JSON array of questions. Each question should have this exact structure:
{
  "id": "unique_id",
  "question": "The question text",
  "options": ["Option A", "Option B", "Option C", "Option D"],
  "correctAnswer": 0,
  "explanation": "Brief explanation of the correct answer"
}

Requirements:
- Make questions engaging and educational
- Ensure all options are plausible
- correctAnswer should be the index (0-3) of the correct option
- Include brief explanations for learning
- Vary question topics within the subject area
- For ${request.difficulty} difficulty: ${this.getDifficultyGuidelines(request.difficulty)}

Topic: ${request.topic}
Question Count: ${request.questionCount}
Difficulty: ${request.difficulty}

Return only the JSON array, no additional text.
`;
  }

  private getDifficultyGuidelines(difficulty: string): string {
    switch (difficulty) {
      case 'easy':
        return 'Focus on basic concepts and well-known facts. Use straightforward language.';
      case 'medium':
        return 'Include some analysis and application of concepts. Mix basic and intermediate knowledge.';
      case 'hard':
        return 'Require deep understanding, analysis, and synthesis. Include complex scenarios.';
      default:
        return 'Appropriate for general knowledge level.';
    }
  }

  private parseQuizResponse(response: string): Question[] {
    try {
      // Clean the response to extract JSON
      const jsonMatch = response.match(/\[.*\]/s);
      if (!jsonMatch) {
        throw new Error('No JSON array found in response');
      }
      
      const questions = JSON.parse(jsonMatch[0]);
      
      // Validate and format questions
      return questions.map((q: any, index: number) => ({
        id: q.id || `q_${index + 1}`,
        question: q.question,
        options: Array.isArray(q.options) ? q.options : [],
        correctAnswer: typeof q.correctAnswer === 'number' ? q.correctAnswer : 0,
        explanation: q.explanation || ''
      })).filter((q: Question) => 
        q.question && q.options.length === 4 && q.correctAnswer >= 0 && q.correctAnswer < 4
      );
    } catch (error) {
      console.error('Error parsing quiz response:', error);
      throw new Error('Failed to parse quiz questions from AI response');
    }
  }

  private getFallbackQuestions(request: QuizGenerationRequest): Question[] {
    // Fallback questions if API fails
    const fallbackSets: Record<string, Question[]> = {
      'Science & Nature': [
        {
          id: 'sci_1',
          question: 'What is the chemical symbol for gold?',
          options: ['Go', 'Au', 'Ag', 'Gd'],
          correctAnswer: 1,
          explanation: 'Au comes from the Latin word "aurum" meaning gold.'
        },
        {
          id: 'sci_2',
          question: 'Which planet is known as the Red Planet?',
          options: ['Venus', 'Jupiter', 'Mars', 'Saturn'],
          correctAnswer: 2,
          explanation: 'Mars appears red due to iron oxide (rust) on its surface.'
        }
      ],
      'History': [
        {
          id: 'hist_1',
          question: 'In which year did World War II end?',
          options: ['1944', '1945', '1946', '1947'],
          correctAnswer: 1,
          explanation: 'World War II ended in 1945 with the surrender of Japan in September.'
        }
      ],
      'Technology': [
        {
          id: 'tech_1',
          question: 'What does "HTTP" stand for?',
          options: ['HyperText Transfer Protocol', 'High Tech Transfer Process', 'HyperText Technology Platform', 'High Transfer Text Protocol'],
          correctAnswer: 0,
          explanation: 'HTTP is the protocol used for transferring web pages on the internet.'
        }
      ]
    };

    const questions = fallbackSets[request.topic] || fallbackSets['Science & Nature'];
    return questions.slice(0, request.questionCount);
  }

  async getRecommendations(userStats: any): Promise<string[]> {
    const prompt = `
Based on this user's quiz performance, provide 3-4 personalized study recommendations:

Stats: ${JSON.stringify(userStats, null, 2)}

Return recommendations as a simple array of strings. Focus on:
- Areas for improvement
- Study strategies
- Next topics to explore
- Motivational suggestions

Keep recommendations concise and actionable.
`;

    try {
      const response = await fetch(`${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.8,
            maxOutputTokens: 512,
          }
        })
      });

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (generatedText) {
        // Parse recommendations from response
        const lines = generatedText.split('\n').filter(line => 
          line.trim() && !line.includes('[') && !line.includes(']')
        );
        return lines.slice(0, 4);
      }
    } catch (error) {
      console.error('Error getting recommendations:', error);
    }

    // Fallback recommendations
    return [
      'Focus on your weaker categories to improve overall performance',
      'Try taking quizzes regularly to build a study habit',
      'Review explanations carefully to understand concepts better',
      'Challenge yourself with harder difficulty levels'
    ];
  }
}

// Helper to get API key from user input or environment
export const getGeminiInstance = (): GeminiAI | null => {
  // First try to get from localStorage (user input)
  const apiKey = localStorage.getItem('gemini-api-key');
  
  if (!apiKey) {
    return null;
  }

  return new GeminiAI({ apiKey });
};

// Helper to set API key
export const setGeminiApiKey = (apiKey: string): void => {
  localStorage.setItem('gemini-api-key', apiKey);
};